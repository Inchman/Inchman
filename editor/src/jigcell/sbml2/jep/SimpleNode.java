/**
 * JEP - Java Expression Parser JEP is a Java package for parsing and evaluating mathematical expressions. It currently supports user defined
 * variables, constant, and functions. A number of common mathematical functions and constants are included. Author: Nathan Funk Copyright (C)
 * 2000 Nathan Funk JEP is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. JEP is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with
 * JEP; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package jigcell.sbml2.jep;

public class SimpleNode implements Node {
   protected Node children [];
   protected int id;
   protected Node parent;
   protected Parser parser;

   public SimpleNode (int i) {
      id = i;
   }

   public SimpleNode (Parser p, int i) {
      this (i);
      parser = p;
   }

   /**
    * Accept the visitor.
    */

   public Object childrenAccept (ParserVisitor visitor, Object data) {
      if (children != null) {
         for (int i = 0; i < children.length; ++i)
            children [i].jjtAccept (visitor, data);
      }
      return data;
   }

   /**
    * Accept the visitor in Reverse.
    */

   public Object childrenAcceptReverse (ParserVisitor visitor, Object data) {
      if (children != null) {
         for (int i = children.length - 1; i > -1; --i)
            children [i].jjtAccept (visitor, data);
      }
      return data;
   }

   /* Override this method if you want to customize how the node dumps
      out its children. */
   public void dump (String prefix) {
      System.out.println (toString (prefix));
      if (children != null) {
         for (int i = 0; i < children.length; ++i) {
            SimpleNode n = (SimpleNode) children [i];
            if (n != null)
               n.dump (prefix + " ");
         }
      }
   }

   /**
    * Returns the id of the node (for simpler identification).
    */

   public int getId () {
      return id;
   }

   /**
    * Accept the visitor.
    */

   public Object jjtAccept (ParserVisitor visitor, Object data) {
      return visitor.visit (this, data);
   }

   public void jjtAddChild (Node n, int i) {
      if (children == null)
         children = new Node [i + 1];
      else if (i >= children.length) {
         Node c [] = new Node [i + 1];
         System.arraycopy (children, 0, c, 0, children.length);
         children = c;
      }
      children [i] = n;
   }

   public void jjtClose () {}

   public Node jjtGetChild (int i) {
      return children [i];
   }

   public int jjtGetNumChildren () {
      return (children == null) ? 0 : children.length;
   }

   public Node jjtGetParent () {
      return parent;
   }

   public void jjtOpen () {}

   public void jjtSetParent (Node n) {
      parent = n;
   }

   /* You can override these two methods in subclasses of SimpleNode to
      customize the way the node appears when the tree is dumped.  If
      your output uses more than one line you should override
      toString(String), otherwise overriding toString() is probably all
      you need to do. */
   public String toString () {
      return ParserTreeConstants.jjtNodeName [id];
   }

   public String toString (String prefix) {
      return prefix + toString ();
   }
}
