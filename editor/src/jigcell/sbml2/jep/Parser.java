/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package jigcell.sbml2.jep;

import jigcell.sbml2.jep.function.PostfixMathCommand;
import jigcell.sbml2.jep.function.PostfixMathCommandI;

public class Parser /*@bgen(jjtree)*/ implements ParserTreeConstants, ParserConstants { /*@bgen(jjtree)*/
   public boolean lookingAhead = false;
   public ParserTokenManager token_source;
   public Token jj_nt;
   public Token token;
   protected JJTParserState jjtree = new JJTParserState ();
   JavaCharStream jj_input_stream;
   private final JJCalls jj_2_rtns [] = new JJCalls [4];
   private final int jj_la1 [] = new int [16];
   private final int jj_la1_0 [] = {
      0x1, 0x300000, 0x300000, 0xc00000, 0xc00000, 0x300000, 0x1000000, 0x82000000, 0xa0, 0x0, 0xfc00, 0x70000, 0x70000, 0x4000000, 0x0, 0xa0,
   };
   private final int jj_la1_1 [] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0,};
   private int jj_expentry [];
   private int jj_lasttokens [] = new int [100];
   private boolean jj_rescan = false;
   private boolean jj_semLA;
   private int jj_endpos;
   private int jj_gc = 0;
   private int jj_gen;
   private int jj_kind = -1;
   private int jj_la;
   private int jj_ntk;
   private JEP jep;
   private Token jj_lastpos;
   private Token jj_scanpos;
   private java.util.Vector jj_expentries = new java.util.Vector ();

   final static class JJCalls {
      int arg;
      int gen;
      JJCalls next;
      Token first;
   }

   public Parser (java.io.InputStream stream) {
      jj_input_stream = new JavaCharStream (stream, 1, 1);
      token_source = new ParserTokenManager (jj_input_stream);
      token = new Token ();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public Parser (java.io.Reader stream) {
      jj_input_stream = new JavaCharStream (stream, 1, 1);
      token_source = new ParserTokenManager (jj_input_stream);
      token = new Token ();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public Parser (ParserTokenManager tm) {
      token_source = tm;
      token = new Token ();
      jj_ntk = -1;
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public final void AdditiveExpression () throws ParseException {
      MultiplicativeExpression ();
label_1:
      while (true) {
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case PLUS :
            case MINUS :
               ;
               break;
            default :
               jj_la1 [1] = jj_gen;
               break label_1;
         }
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case PLUS :
               ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc001 = true;
               jjtree.openNodeScope (jjtn001);
               try {
                  jj_consume_token (PLUS);
                  MultiplicativeExpression ();
                  jjtree.closeNodeScope (jjtn001, 2);
                  jjtc001 = false;
                  jjtn001.setFunction ("plus", new PostfixMathCommand (2));
               } catch (Throwable jjte001) {
                  if (jjtc001) {
                     jjtree.clearNodeScope (jjtn001);
                     jjtc001 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte001 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte001;
                  }
                  if (true)
                     throw (Error) jjte001;
               } finally {
                  if (jjtc001)
                     jjtree.closeNodeScope (jjtn001, 2);
               }
               break;
            case MINUS :
               ASTFunNode jjtn002 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc002 = true;
               jjtree.openNodeScope (jjtn002);
               try {
                  jj_consume_token (MINUS);
                  MultiplicativeExpression ();
                  jjtree.closeNodeScope (jjtn002, 2);
                  jjtc002 = false;
                  jjtn002.setFunction ("minus", new PostfixMathCommand (2));
               } catch (Throwable jjte002) {
                  if (jjtc002) {
                     jjtree.clearNodeScope (jjtn002);
                     jjtc002 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte002 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte002;
                  }
                  if (true)
                     throw (Error) jjte002;
               } finally {
                  if (jjtc002)
                     jjtree.closeNodeScope (jjtn002, 2);
               }
               break;
            default :
               jj_la1 [2] = jj_gen;
               jj_consume_token (-1);
               throw new ParseException ();
         }
      }
   }

   public final void AnyConstant () throws ParseException {

      /*@bgen(jjtree) Constant */
      ASTConstant jjtn000 = new ASTConstant (JJTCONSTANT);
      boolean jjtc000 = true;
      jjtree.openNodeScope (jjtn000);
      Object value;
      try {
         value = RealConstant ();
         jjtree.closeNodeScope (jjtn000, true);
         jjtc000 = false;
         jjtn000.setValue (value);
      } catch (Throwable jjte000) {
         if (jjtc000) {
            jjtree.clearNodeScope (jjtn000);
            jjtc000 = false;
         } else
            jjtree.popNode ();
         if (jjte000 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte000;
         }
         if (jjte000 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte000;
         }
         if (true)
            throw (Error) jjte000;
      } finally {
         if (jjtc000)
            jjtree.closeNodeScope (jjtn000, true);
      }
   }

   public final void ArgumentList (int reqArguments, String functionName) throws ParseException {
      int count = 0;
      String errorStr = "";
      if (jj_2_4 (1)) {
         Expression ();
         count++;
label_5:
         while (true) {
            switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
               case 37 :
                  ;
                  break;
               default :
                  jj_la1 [14] = jj_gen;
                  break label_5;
            }
            jj_consume_token (37);
            Expression ();
            count++;
         }
      } else
         ;
      if (reqArguments != count && reqArguments != -1) {
         errorStr = "Function \"" + functionName + "\" requires " + reqArguments + " parameter";
         if (reqArguments != 1)
            errorStr += "s";
         addToErrorList (errorStr);
      }
   }

   public final void Condition () throws ParseException {
      Expression ();
      switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
         case GT :
            ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope (jjtn001);
            try {
               jj_consume_token (GT);
               Expression ();
               jjtree.closeNodeScope (jjtn001, 2);
               jjtc001 = false;
               jjtn001.setFunction ("gt", new PostfixMathCommand (2));
            } catch (Throwable jjte001) {
               if (jjtc001) {
                  jjtree.clearNodeScope (jjtn001);
                  jjtc001 = false;
               } else
                  jjtree.popNode ();
               if (jjte001 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte001;
               }
               if (jjte001 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte001;
               }
               if (true)
                  throw (Error) jjte001;
            } finally {
               if (jjtc001)
                  jjtree.closeNodeScope (jjtn001, 2);
            }
            break;
         case LT :
            ASTFunNode jjtn002 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope (jjtn002);
            try {
               jj_consume_token (LT);
               Expression ();
               jjtree.closeNodeScope (jjtn002, 2);
               jjtc002 = false;
               jjtn002.setFunction ("lt", new PostfixMathCommand (2));
            } catch (Throwable jjte002) {
               if (jjtc002) {
                  jjtree.clearNodeScope (jjtn002);
                  jjtc002 = false;
               } else
                  jjtree.popNode ();
               if (jjte002 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte002;
               }
               if (jjte002 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte002;
               }
               if (true)
                  throw (Error) jjte002;
            } finally {
               if (jjtc002)
                  jjtree.closeNodeScope (jjtn002, 2);
            }
            break;
         case EQ :
            ASTFunNode jjtn003 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc003 = true;
            jjtree.openNodeScope (jjtn003);
            try {
               jj_consume_token (EQ);
               Expression ();
               jjtree.closeNodeScope (jjtn003, 2);
               jjtc003 = false;
               jjtn003.setFunction ("eq", new PostfixMathCommand (2));
            } catch (Throwable jjte003) {
               if (jjtc003) {
                  jjtree.clearNodeScope (jjtn003);
                  jjtc003 = false;
               } else
                  jjtree.popNode ();
               if (jjte003 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte003;
               }
               if (jjte003 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte003;
               }
               if (true)
                  throw (Error) jjte003;
            } finally {
               if (jjtc003)
                  jjtree.closeNodeScope (jjtn003, 2);
            }
            break;
         case LE :
            ASTFunNode jjtn004 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc004 = true;
            jjtree.openNodeScope (jjtn004);
            try {
               jj_consume_token (LE);
               Expression ();
               jjtree.closeNodeScope (jjtn004, 2);
               jjtc004 = false;
               jjtn004.setFunction ("leq", new PostfixMathCommand (2));
            } catch (Throwable jjte004) {
               if (jjtc004) {
                  jjtree.clearNodeScope (jjtn004);
                  jjtc004 = false;
               } else
                  jjtree.popNode ();
               if (jjte004 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte004;
               }
               if (jjte004 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte004;
               }
               if (true)
                  throw (Error) jjte004;
            } finally {
               if (jjtc004)
                  jjtree.closeNodeScope (jjtn004, 2);
            }
            break;
         case GE :
            ASTFunNode jjtn005 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc005 = true;
            jjtree.openNodeScope (jjtn005);
            try {
               jj_consume_token (GE);
               Expression ();
               jjtree.closeNodeScope (jjtn005, 2);
               jjtc005 = false;
               jjtn005.setFunction ("geq", new PostfixMathCommand (2));
            } catch (Throwable jjte005) {
               if (jjtc005) {
                  jjtree.clearNodeScope (jjtn005);
                  jjtc005 = false;
               } else
                  jjtree.popNode ();
               if (jjte005 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte005;
               }
               if (jjte005 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte005;
               }
               if (true)
                  throw (Error) jjte005;
            } finally {
               if (jjtc005)
                  jjtree.closeNodeScope (jjtn005, 2);
            }
            break;
         case NE :
            ASTFunNode jjtn006 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc006 = true;
            jjtree.openNodeScope (jjtn006);
            try {
               jj_consume_token (NE);
               Expression ();
               jjtree.closeNodeScope (jjtn006, 2);
               jjtc006 = false;
               jjtn006.setFunction ("neq", new PostfixMathCommand (2));
            } catch (Throwable jjte006) {
               if (jjtc006) {
                  jjtree.clearNodeScope (jjtn006);
                  jjtc006 = false;
               } else
                  jjtree.popNode ();
               if (jjte006 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte006;
               }
               if (jjte006 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte006;
               }
               if (true)
                  throw (Error) jjte006;
            } finally {
               if (jjtc006)
                  jjtree.closeNodeScope (jjtn006, 2);
            }
            break;
         default :
            jj_la1 [10] = jj_gen;
            jj_consume_token (-1);
            throw new ParseException ();
      }
   }

   public final void ConnectiveCondition () throws ParseException {
      Condition ();
label_3:
      while (true) {
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case AND :
            case OR :
            case XOR :
               ;
               break;
            default :
               jj_la1 [11] = jj_gen;
               break label_3;
         }
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case AND :
               ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc001 = true;
               jjtree.openNodeScope (jjtn001);
               try {
                  jj_consume_token (AND);
                  Condition ();
                  jjtree.closeNodeScope (jjtn001, 2);
                  jjtc001 = false;
                  jjtn001.setFunction ("and", new PostfixMathCommand (2));
               } catch (Throwable jjte001) {
                  if (jjtc001) {
                     jjtree.clearNodeScope (jjtn001);
                     jjtc001 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte001 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte001;
                  }
                  if (true)
                     throw (Error) jjte001;
               } finally {
                  if (jjtc001)
                     jjtree.closeNodeScope (jjtn001, 2);
               }
               break;
            case OR :
               ASTFunNode jjtn002 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc002 = true;
               jjtree.openNodeScope (jjtn002);
               try {
                  jj_consume_token (OR);
                  Condition ();
                  jjtree.closeNodeScope (jjtn002, 2);
                  jjtc002 = false;
                  jjtn002.setFunction ("or", new PostfixMathCommand (2));
               } catch (Throwable jjte002) {
                  if (jjtc002) {
                     jjtree.clearNodeScope (jjtn002);
                     jjtc002 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte002 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte002;
                  }
                  if (true)
                     throw (Error) jjte002;
               } finally {
                  if (jjtc002)
                     jjtree.closeNodeScope (jjtn002, 2);
               }
               break;
            case XOR :
               ASTFunNode jjtn003 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc003 = true;
               jjtree.openNodeScope (jjtn003);
               try {
                  jj_consume_token (XOR);
                  Condition ();
                  jjtree.closeNodeScope (jjtn003, 2);
                  jjtc003 = false;
                  jjtn003.setFunction ("xor", new PostfixMathCommand (2));
               } catch (Throwable jjte003) {
                  if (jjtc003) {
                     jjtree.clearNodeScope (jjtn003);
                     jjtc003 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte003 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte003;
                  }
                  if (jjte003 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte003;
                  }
                  if (true)
                     throw (Error) jjte003;
               } finally {
                  if (jjtc003)
                     jjtree.closeNodeScope (jjtn003, 2);
               }
               break;
            default :
               jj_la1 [12] = jj_gen;
               jj_consume_token (-1);
               throw new ParseException ();
         }
      }
   }

   public final void Expression () throws ParseException {
      AdditiveExpression ();
   }

   public final void Function () throws ParseException {
      int reqArguments = 0;
      String identString = "";
      ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope (jjtn001);
      try {
         identString = Identifier ();
         if (jep.funTab.containsKey (identString)) {

            //Set number of required arguments
            reqArguments = ((PostfixMathCommandI) jep.funTab.get (identString)).getNumberOfParameters ();
            jjtn001.setFunction (identString, (PostfixMathCommandI) jep.funTab.get (identString));
         } else
            addToErrorList ("!!! Unrecognized function \"" + identString + "\"");
         jj_consume_token (35);
         ArgumentList (reqArguments, identString);
         jj_consume_token (36);
      } catch (Throwable jjte001) {
         if (jjtc001) {
            jjtree.clearNodeScope (jjtn001);
            jjtc001 = false;
         } else
            jjtree.popNode ();
         if (jjte001 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte001;
         }
         if (jjte001 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte001;
         }
         if (true)
            throw (Error) jjte001;
      } finally {
         if (jjtc001)
            jjtree.closeNodeScope (jjtn001, true);
      }
   }

   public final String Identifier () throws ParseException {
      Token t;
      t = jj_consume_token (IDENTIFIER);
      if (true)
         return t.image;
      throw new Error ("Missing return statement in function");
   }

   public final void MultiplicativeExpression () throws ParseException {
      UnaryExpression ();
label_2:
      while (true) {
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case MUL :
            case DIV :
               ;
               break;
            default :
               jj_la1 [3] = jj_gen;
               break label_2;
         }
         switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
            case MUL :
               ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc001 = true;
               jjtree.openNodeScope (jjtn001);
               try {
                  jj_consume_token (MUL);
                  UnaryExpression ();
                  jjtree.closeNodeScope (jjtn001, 2);
                  jjtc001 = false;
                  jjtn001.setFunction ("times", new PostfixMathCommand (2));
               } catch (Throwable jjte001) {
                  if (jjtc001) {
                     jjtree.clearNodeScope (jjtn001);
                     jjtc001 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte001 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte001;
                  }
                  if (true)
                     throw (Error) jjte001;
               } finally {
                  if (jjtc001)
                     jjtree.closeNodeScope (jjtn001, 2);
               }
               break;
            case DIV :
               ASTFunNode jjtn002 = new ASTFunNode (JJTFUNNODE);
               boolean jjtc002 = true;
               jjtree.openNodeScope (jjtn002);
               try {
                  jj_consume_token (DIV);
                  UnaryExpression ();
                  jjtree.closeNodeScope (jjtn002, 2);
                  jjtc002 = false;
                  jjtn002.setFunction ("divide", new PostfixMathCommand (2));
               } catch (Throwable jjte002) {
                  if (jjtc002) {
                     jjtree.clearNodeScope (jjtn002);
                     jjtc002 = false;
                  } else
                     jjtree.popNode ();
                  if (jjte002 instanceof RuntimeException) {
                     if (true)
                        throw (RuntimeException) jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                     if (true)
                        throw (ParseException) jjte002;
                  }
                  if (true)
                     throw (Error) jjte002;
               } finally {
                  if (jjtc002)
                     jjtree.closeNodeScope (jjtn002, 2);
               }
               break;
            default :
               jj_la1 [4] = jj_gen;
               jj_consume_token (-1);
               throw new ParseException ();
         }
      }
   }

   public final void NotConnectiveCondition () throws ParseException {
      ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope (jjtn001);
      try {
         jj_consume_token (NOT);
         ConnectiveCondition ();
         jjtree.closeNodeScope (jjtn001, 1);
         jjtc001 = false;
         jjtn001.setFunction ("not", new PostfixMathCommand (1));
      } catch (Throwable jjte001) {
         if (jjtc001) {
            jjtree.clearNodeScope (jjtn001);
            jjtc001 = false;
         } else
            jjtree.popNode ();
         if (jjte001 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte001;
         }
         if (jjte001 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte001;
         }
         if (true)
            throw (Error) jjte001;
      } finally {
         if (jjtc001)
            jjtree.closeNodeScope (jjtn001, 1);
      }
   }

   public final void Piecewise () throws ParseException {
      ASTPiecewise jjtn004 = new ASTPiecewise (JJTPIECEWISE);
      boolean jjtc004 = true;
      jjtree.openNodeScope (jjtn004);
      try {
         ASTIfThen jjtn001 = new ASTIfThen (JJTIFTHEN);
         boolean jjtc001 = true;
         jjtree.openNodeScope (jjtn001);
         try {
            jj_consume_token (IF);
            jj_consume_token (35);
            ConnectiveCondition ();
            jj_consume_token (36);
            jj_consume_token (THEN);
            jj_consume_token (35);
            Expression ();
         } catch (Throwable jjte001) {
            if (jjtc001) {
               jjtree.clearNodeScope (jjtn001);
               jjtc001 = false;
            } else
               jjtree.popNode ();
            if (jjte001 instanceof RuntimeException) {
               if (true)
                  throw (RuntimeException) jjte001;
            }
            if (jjte001 instanceof ParseException) {
               if (true)
                  throw (ParseException) jjte001;
            }
            if (true)
               throw (Error) jjte001;
         } finally {
            if (jjtc001)
               jjtree.closeNodeScope (jjtn001, true);
         }
         jj_consume_token (36);
label_4:
         while (true) {
            switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
               case ELSEIF :
                  ;
                  break;
               default :
                  jj_la1 [13] = jj_gen;
                  break label_4;
            }
            jj_consume_token (ELSEIF);
            jj_consume_token (35);
            ASTElseIfThen jjtn002 = new ASTElseIfThen (JJTELSEIFTHEN);
            boolean jjtc002 = true;
            jjtree.openNodeScope (jjtn002);
            try {
               ConnectiveCondition ();
               jj_consume_token (36);
               jj_consume_token (THEN);
               jj_consume_token (35);
               Expression ();
            } catch (Throwable jjte002) {
               if (jjtc002) {
                  jjtree.clearNodeScope (jjtn002);
                  jjtc002 = false;
               } else
                  jjtree.popNode ();
               if (jjte002 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte002;
               }
               if (jjte002 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte002;
               }
               if (true)
                  throw (Error) jjte002;
            } finally {
               if (jjtc002)
                  jjtree.closeNodeScope (jjtn002, true);
            }
            jj_consume_token (36);
         }
         jj_consume_token (ELSE);
         jj_consume_token (35);
         ASTElse jjtn003 = new ASTElse (JJTELSE);
         boolean jjtc003 = true;
         jjtree.openNodeScope (jjtn003);
         try {
            Expression ();
         } catch (Throwable jjte003) {
            if (jjtc003) {
               jjtree.clearNodeScope (jjtn003);
               jjtc003 = false;
            } else
               jjtree.popNode ();
            if (jjte003 instanceof RuntimeException) {
               if (true)
                  throw (RuntimeException) jjte003;
            }
            if (jjte003 instanceof ParseException) {
               if (true)
                  throw (ParseException) jjte003;
            }
            if (true)
               throw (Error) jjte003;
         } finally {
            if (jjtc003)
               jjtree.closeNodeScope (jjtn003, true);
         }
         jj_consume_token (36);
      } catch (Throwable jjte004) {
         if (jjtc004) {
            jjtree.clearNodeScope (jjtn004);
            jjtc004 = false;
         } else
            jjtree.popNode ();
         if (jjte004 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte004;
         }
         if (jjte004 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte004;
         }
         if (true)
            throw (Error) jjte004;
      } finally {
         if (jjtc004)
            jjtree.closeNodeScope (jjtn004, true);
      }
   }

   public final void PowerExpression () throws ParseException {
      UnaryExpressionNotPlusMinus ();
      switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
         case POWER :
            ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope (jjtn001);
            try {
               jj_consume_token (POWER);
               UnaryExpression ();
               jjtree.closeNodeScope (jjtn001, 2);
               jjtc001 = false;
               jjtn001.setFunction ("power", new PostfixMathCommand (2));
            } catch (Throwable jjte001) {
               if (jjtc001) {
                  jjtree.clearNodeScope (jjtn001);
                  jjtc001 = false;
               } else
                  jjtree.popNode ();
               if (jjte001 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte001;
               }
               if (jjte001 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte001;
               }
               if (true)
                  throw (Error) jjte001;
            } finally {
               if (jjtc001)
                  jjtree.closeNodeScope (jjtn001, 2);
            }
            break;
         default :
            jj_la1 [6] = jj_gen;
            ;
      }
   }

   public final Object RealConstant () throws ParseException {
      Token t;
      Object value;
      switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
         case INTEGER_LITERAL :
            t = jj_consume_token (INTEGER_LITERAL);
            break;
         case FLOATING_POINT_LITERAL :
            t = jj_consume_token (FLOATING_POINT_LITERAL);
            break;
         default :
            jj_la1 [15] = jj_gen;
            jj_consume_token (-1);
            throw new ParseException ();
      }
      try {
         Double temp = new Double (t.image);
         value = jep.getNumberFactory ().createNumber (temp.doubleValue ());
      } catch (Exception e) {
         value = null;
         addToErrorList ("Can't parse \"" + t.image + "\"");
      }
      if (true)
         return value;
      throw new Error ("Missing return statement in function");
   }

   /**
    * GRAMMAR START
    */

   public final ASTStart Start () throws ParseException {

      /*@bgen(jjtree) Start */
      ASTStart jjtn000 = new ASTStart (JJTSTART);
      boolean jjtc000 = true;
      jjtree.openNodeScope (jjtn000);
      try {
         if (jj_2_1 (1)) {
            Expression ();
            jj_consume_token (0);
            jjtree.closeNodeScope (jjtn000, true);
            jjtc000 = false;
            if (true)
               return jjtn000;
         } else {
            switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
               case 0 :
                  jj_consume_token (0);
                  jjtree.closeNodeScope (jjtn000, true);
                  jjtc000 = false;
                   {
                     if (true)
                        throw new ParseException ("No expression entered");
                  }
                  addToErrorList ("No expression entered");
                   {
                     if (true)
                        return null;
                  }
                  break;
               default :
                  jj_la1 [0] = jj_gen;
                  jj_consume_token (-1);
                  throw new ParseException ();
            }
         }
      } catch (Throwable jjte000) {
         if (jjtc000) {
            jjtree.clearNodeScope (jjtn000);
            jjtc000 = false;
         } else
            jjtree.popNode ();
         if (jjte000 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte000;
         }
         if (jjte000 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte000;
         }
         if (true)
            throw (Error) jjte000;
      } finally {
         if (jjtc000)
            jjtree.closeNodeScope (jjtn000, true);
      }
      throw new Error ("Missing return statement in function");
   }

   public final void UnaryExpression () throws ParseException {
      switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
         case PLUS :
            ASTFunNode jjtn001 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc001 = true;
            jjtree.openNodeScope (jjtn001);
            try {
               jj_consume_token (PLUS);
               UnaryExpression ();
               jjtree.closeNodeScope (jjtn001, 1);
               jjtc001 = false;
               jjtn001.setFunction ("plus", new PostfixMathCommand (1));
            } catch (Throwable jjte001) {
               if (jjtc001) {
                  jjtree.clearNodeScope (jjtn001);
                  jjtc001 = false;
               } else
                  jjtree.popNode ();
               if (jjte001 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte001;
               }
               if (jjte001 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte001;
               }
               if (true)
                  throw (Error) jjte001;
            } finally {
               if (jjtc001)
                  jjtree.closeNodeScope (jjtn001, 1);
            }
            break;
         case MINUS :
            ASTFunNode jjtn002 = new ASTFunNode (JJTFUNNODE);
            boolean jjtc002 = true;
            jjtree.openNodeScope (jjtn002);
            try {
               jj_consume_token (MINUS);
               UnaryExpression ();
               jjtree.closeNodeScope (jjtn002, 1);
               jjtc002 = false;
               jjtn002.setFunction ("minus", new PostfixMathCommand (1));
            } catch (Throwable jjte002) {
               if (jjtc002) {
                  jjtree.clearNodeScope (jjtn002);
                  jjtc002 = false;
               } else
                  jjtree.popNode ();
               if (jjte002 instanceof RuntimeException) {
                  if (true)
                     throw (RuntimeException) jjte002;
               }
               if (jjte002 instanceof ParseException) {
                  if (true)
                     throw (ParseException) jjte002;
               }
               if (true)
                  throw (Error) jjte002;
            } finally {
               if (jjtc002)
                  jjtree.closeNodeScope (jjtn002, 1);
            }
            break;
         default :
            jj_la1 [5] = jj_gen;
            if (jj_2_2 (1))
               PowerExpression ();
            else {
               jj_consume_token (-1);
               throw new ParseException ();
            }
      }
   }

   public final void UnaryExpressionNotPlusMinus () throws ParseException {
      String identString = "";
      int type;
      switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
         case INTEGER_LITERAL :
         case FLOATING_POINT_LITERAL :
            AnyConstant ();
            break;
         default :
            jj_la1 [8] = jj_gen;
            if (jj_2_3 (1)) {
               if (getToken (1).kind == IDENTIFIER && jep.funTab.containsKey (getToken (1).image))
                  Function ();
               else {
                  switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
                     case IDENTIFIER :
                        Variable ();
                        break;
                     case IF :
                        Piecewise ();
                        break;
                     default :
                        jj_la1 [7] = jj_gen;
                        jj_consume_token (-1);
                        throw new ParseException ();
                  }
               }
            } else {
               switch ((jj_ntk == -1) ? jj_ntk () : jj_ntk) {
                  case 35 :
                     jj_consume_token (35);
                     Expression ();
                     jj_consume_token (36);
                     break;
                  default :
                     jj_la1 [9] = jj_gen;
                     jj_consume_token (-1);
                     throw new ParseException ();
               }
            }
      }
   }

   public final void Variable () throws ParseException {
      String identString = "";
      ASTVarNode jjtn001 = new ASTVarNode (JJTVARNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope (jjtn001);
      try {
         identString = Identifier ();
         jjtree.closeNodeScope (jjtn001, true);
         jjtc001 = false;
         if (jep.symTab.containsKey (identString))
            jjtn001.setName (identString);
         else {
            jep.symTab.put (identString, identString);
            jjtn001.setName (identString);
         }
      } catch (Throwable jjte001) {
         if (jjtc001) {
            jjtree.clearNodeScope (jjtn001);
            jjtc001 = false;
         } else
            jjtree.popNode ();
         if (jjte001 instanceof RuntimeException) {
            if (true)
               throw (RuntimeException) jjte001;
         }
         if (jjte001 instanceof ParseException) {
            if (true)
               throw (ParseException) jjte001;
         }
         if (true)
            throw (Error) jjte001;
      } finally {
         if (jjtc001)
            jjtree.closeNodeScope (jjtn001, true);
      }
   }

   public void ReInit (java.io.InputStream stream) {
      jj_input_stream.ReInit (stream, 1, 1);
      token_source.ReInit (jj_input_stream);
      token = new Token ();
      jj_ntk = -1;
      jjtree.reset ();
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public void ReInit (java.io.Reader stream) {
      jj_input_stream.ReInit (stream, 1, 1);
      token_source.ReInit (jj_input_stream);
      token = new Token ();
      jj_ntk = -1;
      jjtree.reset ();
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public void ReInit (ParserTokenManager tm) {
      token_source = tm;
      token = new Token ();
      jj_ntk = -1;
      jjtree.reset ();
      jj_gen = 0;
      for (int i = 0; i < 16; i++)
         jj_la1 [i] = -1;
      for (int i = 0; i < jj_2_rtns.length; i++)
         jj_2_rtns [i] = new JJCalls ();
   }

   public final void disable_tracing () {}

   public final void enable_tracing () {}

   public final ParseException generateParseException () {
      jj_expentries.removeAllElements ();
      boolean la1tokens [] = new boolean [38];
      for (int i = 0; i < 38; i++)
         la1tokens [i] = false;
      if (jj_kind >= 0) {
         la1tokens [jj_kind] = true;
         jj_kind = -1;
      }
      for (int i = 0; i < 16; i++) {
         if (jj_la1 [i] == jj_gen) {
            for (int j = 0; j < 32; j++) {
               if ((jj_la1_0 [i] & (1 << j)) != 0)
                  la1tokens [j] = true;
               if ((jj_la1_1 [i] & (1 << j)) != 0)
                  la1tokens [32 + j] = true;
            }
         }
      }
      for (int i = 0; i < 38; i++) {
         if (la1tokens [i]) {
            jj_expentry = new int [1];
            jj_expentry [0] = i;
            jj_expentries.addElement (jj_expentry);
         }
      }
      jj_endpos = 0;
      jj_rescan_token ();
      jj_add_error_token (0, 0);
      int exptokseq [][] = new int [jj_expentries.size ()][];
      for (int i = 0; i < jj_expentries.size (); i++)
         exptokseq [i] = (int []) jj_expentries.elementAt (i);
      return new ParseException (token, exptokseq, tokenImage);
   }

   public final Token getNextToken () {
      if (token.next != null)
         token = token.next;
      else
         token = token.next = token_source.getNextToken ();
      jj_ntk = -1;
      jj_gen++;
      return token;
   }

   public final Token getToken (int index) {
      Token t = lookingAhead ? jj_scanpos : token;
      for (int i = 0; i < index; i++) {
         if (t.next != null)
            t = t.next;
         else
            t = t.next = token_source.getNextToken ();
      }
      return t;
   }

   public Node parseStream (java.io.Reader stream, JEP jep_in) throws ParseException {
      ReInit (stream);
      jep = jep_in;

      // Parse the expression, and return the
      return Start ().jjtGetChild (0);
   }

   private void addToErrorList (String errorStr) {
      jep.errorList.addElement (errorStr);
   }

   private final boolean jj_2_1 (int xla) {
      jj_la = xla;
      jj_lastpos = jj_scanpos = token;
      boolean retval = !jj_3_1 ();
      jj_save (0, xla);
      return retval;
   }

   private final boolean jj_2_2 (int xla) {
      jj_la = xla;
      jj_lastpos = jj_scanpos = token;
      boolean retval = !jj_3_2 ();
      jj_save (1, xla);
      return retval;
   }

   private final boolean jj_2_3 (int xla) {
      jj_la = xla;
      jj_lastpos = jj_scanpos = token;
      boolean retval = !jj_3_3 ();
      jj_save (2, xla);
      return retval;
   }

   private final boolean jj_2_4 (int xla) {
      jj_la = xla;
      jj_lastpos = jj_scanpos = token;
      boolean retval = !jj_3_4 ();
      jj_save (3, xla);
      return retval;
   }

   private final boolean jj_3R_10 () {
      if (jj_3R_15 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_11 () {
      if (jj_3R_16 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_12 () {
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_17 ()) {
         jj_scanpos = xsp;
         if (jj_3_3 ()) {
            jj_scanpos = xsp;
            if (jj_3R_18 ())
               return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos)
               return false;
         } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
      } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_13 () {
      if (jj_3R_19 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_14 () {
      if (jj_3R_19 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_15 () {
      if (jj_scan_token (IF))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_16 () {
      if (jj_3R_20 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_17 () {
      if (jj_3R_21 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_18 () {
      if (jj_scan_token (35))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_19 () {
      if (jj_scan_token (IDENTIFIER))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_20 () {
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_22 ()) {
         jj_scanpos = xsp;
         if (jj_3R_23 ()) {
            jj_scanpos = xsp;
            if (jj_3_2 ())
               return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos)
               return false;
         } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
      } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_21 () {
      if (jj_3R_24 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_22 () {
      if (jj_scan_token (PLUS))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_23 () {
      if (jj_scan_token (MINUS))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_24 () {
      Token xsp;
      xsp = jj_scanpos;
      if (jj_3R_25 ()) {
         jj_scanpos = xsp;
         if (jj_3R_26 ())
            return true;
         if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
      } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_25 () {
      if (jj_scan_token (INTEGER_LITERAL))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_26 () {
      if (jj_scan_token (FLOATING_POINT_LITERAL))
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_6 () {
      if (jj_3R_11 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_7 () {
      if (jj_3R_12 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_8 () {
      if (jj_3R_13 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3R_9 () {
      if (jj_3R_14 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3_1 () {
      if (jj_3R_6 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3_2 () {
      if (jj_3R_7 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3_3 () {
      Token xsp;
      xsp = jj_scanpos;
      lookingAhead = true;
      jj_semLA = getToken (1).kind == IDENTIFIER && jep.funTab.containsKey (getToken (1).image);
      lookingAhead = false;
      if (!jj_semLA || jj_3R_8 ()) {
         jj_scanpos = xsp;
         if (jj_3R_9 ()) {
            jj_scanpos = xsp;
            if (jj_3R_10 ())
               return true;
            if (jj_la == 0 && jj_scanpos == jj_lastpos)
               return false;
         } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
            return false;
      } else if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final boolean jj_3_4 () {
      if (jj_3R_6 ())
         return true;
      if (jj_la == 0 && jj_scanpos == jj_lastpos)
         return false;
      return false;
   }

   private final Token jj_consume_token (int kind) throws ParseException {
      Token oldToken;
      if ((oldToken = token).next != null)
         token = token.next;
      else
         token = token.next = token_source.getNextToken ();
      jj_ntk = -1;
      if (token.kind == kind) {
         jj_gen++;
         if (++jj_gc > 100) {
            jj_gc = 0;
            for (int i = 0; i < jj_2_rtns.length; i++) {
               JJCalls c = jj_2_rtns [i];
               while (c != null) {
                  if (c.gen < jj_gen)
                     c.first = null;
                  c = c.next;
               }
            }
         }
         return token;
      }
      token = oldToken;
      jj_kind = kind;
      throw generateParseException ();
   }

   private final int jj_ntk () {
      if ((jj_nt = token.next) == null)
         return (jj_ntk = (token.next = token_source.getNextToken ()).kind);
      else
         return (jj_ntk = jj_nt.kind);
   }

   private final boolean jj_scan_token (int kind) {
      if (jj_scanpos == jj_lastpos) {
         jj_la--;
         if (jj_scanpos.next == null)
            jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken ();
         else
            jj_lastpos = jj_scanpos = jj_scanpos.next;
      } else
         jj_scanpos = jj_scanpos.next;
      if (jj_rescan) {
         int i = 0;
         Token tok = token;
         while (tok != null && tok != jj_scanpos) {
            i++;
            tok = tok.next;
         }
         if (tok != null)
            jj_add_error_token (kind, i);
      }
      return (jj_scanpos.kind != kind);
   }

   private void jj_add_error_token (int kind, int pos) {
      if (pos >= 100)
         return;
      if (pos == jj_endpos + 1)
         jj_lasttokens [jj_endpos++] = kind;
      else if (jj_endpos != 0) {
         jj_expentry = new int [jj_endpos];
         for (int i = 0; i < jj_endpos; i++)
            jj_expentry [i] = jj_lasttokens [i];
         boolean exists = false;
         for (java.util.Enumeration e = jj_expentries.elements (); e.hasMoreElements (); ) {
            int oldentry [] = (int []) (e.nextElement ());
            if (oldentry.length == jj_expentry.length) {
               exists = true;
               for (int i = 0; i < jj_expentry.length; i++) {
                  if (oldentry [i] != jj_expentry [i]) {
                     exists = false;
                     break;
                  }
               }
               if (exists)
                  break;
            }
         }
         if (!exists)
            jj_expentries.addElement (jj_expentry);
         if (pos != 0)
            jj_lasttokens [(jj_endpos = pos) - 1] = kind;
      }
   }

   private final void jj_rescan_token () {
      jj_rescan = true;
      for (int i = 0; i < 4; i++) {
         JJCalls p = jj_2_rtns [i];
         do {
            if (p.gen > jj_gen) {
               jj_la = p.arg;
               jj_lastpos = jj_scanpos = p.first;
               switch (i) {
                  case 0 :
                     jj_3_1 ();
                     break;
                  case 1 :
                     jj_3_2 ();
                     break;
                  case 2 :
                     jj_3_3 ();
                     break;
                  case 3 :
                     jj_3_4 ();
                     break;
               }
            }
            p = p.next;
         } while (p != null);
      }
      jj_rescan = false;
   }

   private final void jj_save (int index, int xla) {
      JJCalls p = jj_2_rtns [index];
      while (p.gen > jj_gen) {
         if (p.next == null) {
            p = p.next = new JJCalls ();
            break;
         }
         p = p.next;
      }
      p.gen = jj_gen + xla - jj_la;
      p.first = token;
      p.arg = xla;
   }
}
