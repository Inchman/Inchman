/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//***************************************************************

JEP - Java Expression Parser
    JEP is a Java package for parsing and evaluating mathematical
	expressions. It currently supports user defined variables,
	constant, and functions. A number of common mathematical
	functions and constants are included.

Author: Nathan Funk
Copyright (C) 2000 Nathan Funk

    JEP is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    JEP is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with JEP; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


This file contains the grammar from which the parser is
generated. The parser generation tools being used are JavaCC
and its component JJTree. JJTree processes the .jjt file and
generates the .jj file. This file is then used be JavaCC to
generate the final java classes.

Knowledge of parser generation is definetly beneficial if you
are planning to make changes to this file. Although many parts
are self explanitory, it is helpful to know how the grammar is
handled by JJTree and JavaCC.

You can follow the structure of the grammar by starting in the
line which reads "ASTStart Start() #Start : {}". From there you
will be able to trace the same path the parser follows when
parsing an expression.

The concept of precedence is very important. Since this is a
recursive descent parser, it is easy to see which operators have
higher order of precedence. The following table outlines the
order incorporated in this grammar.

Order of precedence (from lowest to highest):

   ||  XOR Piecewise or  (logical), XOR (logical), Piecewise
   &&               and (logical)
   =   !=           equal, not equal
   <   >   <=  >=   less, greater, less or equal, greater or equal
   +   -            addition, subtraction
   *   /            multiplication, division
   !   +   -        not, unary +/-
   ^                power

The order of precedence is greatly inspired by the operator
precedence of the C language. See "The C Programming Language"
Kernighan & Richie 2nd Ed p.53. Java also uses a very similar
precedence. Note that the '^' operator is used for bitwise 
exclusive OR in Java and C, but represents the power operator
in this grammar.

***************************************************************/



/***************************************************************
OPTIONS
***************************************************************/
options {
	JAVA_UNICODE_ESCAPE = true;                                                           
	STATIC = false;
}


/***************************************************************
PARSER BEGIN
***************************************************************/

PARSER_BEGIN(Parser)
package jigcell.modelbuilder.jep;

import jigcell.modelbuilder.jep.function.*;
import jigcell.modelbuilder.jep.type.*;
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
	private JEP     jep;

	public Node parseStream(java.io.Reader stream, JEP jep_in)
							throws ParseException {
		ReInit(stream);
		jep = jep_in;

		// Parse the expression, and return the 
		return Start().jjtGetChild(0);
	}

	private void addToErrorList(String errorStr) {
		jep.errorList.addElement(errorStr);		
	}
}

PARSER_END(Parser)


/***************************************************************
SKIP
***************************************************************/

SKIP :
{
  " "
  | "\t"
  | "\n"
  | "\r"
}


/***************************************************************
TOKENS
***************************************************************/

TOKEN : /* LITERALS */
{
	< INTEGER_LITERAL:
		<DECIMAL_LITERAL>
	>
|
	< #DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
	< FLOATING_POINT_LITERAL:
		(["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
		| "." (["0"-"9"])+ (<EXPONENT>)?
		| (["0"-"9"])+ <EXPONENT>
	>
|
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}



/* OPERATORS */
TOKEN:
{
        < ESCAP: "\\" >
|	< GT:   ">"  >
|	< LT:   "<"  >
|	< EQ:   "=" >
|	< LE:   "<=" >
|	< GE:   ">=" >
|	< NE:   "!=" >
|	< AND:  "AND" >
|	< OR:   "OR" >
|       < XOR:  "XOR">
|       < NOT:  "NOT">
|	< PLUS: "+"  >
|	< MINUS:"-"  >
|	< MUL:  "*"  >
|	< DIV:  "/"  >
|	< POWER:"^"  >
|	< IF:   "if" >
|	< ELSEIF:"elseif">
|	< ELSE: "else">
|	< THEN: "then">
|	< TRUE: "true">
|	< FALSE: "false">     
}



TOKEN :
{
	< IDENTIFIER: (<LETTER>|<DIGIT>|<ESC>)* >
|
	< #LETTER:
	[
                "!"-"'",
                ".",
                ":"-";",
                "?",
                "@",
                "A"-"[",
                "]",
                "_"-"\ufffd"
	]
	>	
|
	< #DIGIT: ["0"-"9"] >
|
        < #ESC: <ESCAP>(<ESCAP>|<GT>|<LT>|<EQ>|<LE>|<GE>|<NE>|<PLUS>|<MINUS>|<MUL>|<DIV>|<POWER>|")"|"("|",")>

}
/***************************************************************
GRAMMAR START
***************************************************************/

ASTStart Start()        :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	Expression() <EOF>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { return jjtn000; }
	|  <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		throw new ParseException("No expression entered");
		addToErrorList("No expression entered");
		return null;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression() : {}
{
	AdditiveExpression()
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() 
  (/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
     }
     try {
/*@egen*/ 
     ( <PLUS> MultiplicativeExpression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtc001 = false;
       }
/*@egen*/
       {
	    jjtn001.setFunction("plus",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte001) {
       if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         throw (RuntimeException)jjte001;
       }
       if (jjte001 instanceof ParseException) {
         throw (ParseException)jjte001;
       }
       throw (Error)jjte001;
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
       }
     }
/*@egen*/
  |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/  (<MINUS> MultiplicativeExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
	    jjtn002.setFunction("minus",  new PostfixMathCommand(2));
      }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte002) {
       if (jjtc002) {
         jjtree.clearNodeScope(jjtn002);
         jjtc002 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte002 instanceof RuntimeException) {
         throw (RuntimeException)jjte002;
       }
       if (jjte002 instanceof ParseException) {
         throw (ParseException)jjte002;
       }
       throw (Error)jjte002;
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002,  2);
       }
     }
/*@egen*/
  )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() 
  (/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
     }
     try {
/*@egen*/ 
     ( <MUL> UnaryExpression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtc001 = false;
       }
/*@egen*/
       {
	    jjtn001.setFunction("times",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte001) {
       if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         throw (RuntimeException)jjte001;
       }
       if (jjte001 instanceof ParseException) {
         throw (ParseException)jjte001;
       }
       throw (Error)jjte001;
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
       }
     }
/*@egen*/
  |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/  (<DIV> UnaryExpression()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
	    jjtn002.setFunction("divide",  new PostfixMathCommand(2));
      }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte002) {
       if (jjtc002) {
         jjtree.clearNodeScope(jjtn002);
         jjtc002 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte002 instanceof RuntimeException) {
         throw (RuntimeException)jjte002;
       }
       if (jjte002 instanceof ParseException) {
         throw (ParseException)jjte002;
       }
       throw (Error)jjte002;
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002,  2);
       }
     }
/*@egen*/
  )*
}

void UnaryExpression() :
{}
{/*@bgen(jjtree) #FunNode( 1) */
  {
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  ( <PLUS> UnaryExpression()/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn001,  1);
                              jjtc001 = false;
                            }
/*@egen*/{
	    jjtn001.setFunction("plus",  new PostfixMathCommand(1));
      }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  1);
    }
  }
/*@egen*/
|/*@bgen(jjtree) #FunNode( 1) */
  {
    ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ ( <MINUS> UnaryExpression()/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn002,  1);
                               jjtc002 = false;
                             }
/*@egen*/{
	    jjtn002.setFunction("minus",  new PostfixMathCommand(1));
  }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      throw (RuntimeException)jjte002;
    }
    if (jjte002 instanceof ParseException) {
      throw (ParseException)jjte002;
    }
    throw (Error)jjte002;
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002,  1);
    }
  }
/*@egen*/
|
  PowerExpression()
}

void PowerExpression() :
{
}
{
  UnaryExpressionNotPlusMinus()
  [/*@bgen(jjtree) #FunNode( 2) */
  {
    ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  ( <POWER> UnaryExpression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
    }
/*@egen*/
    {
      jjtn001.setFunction("power", new PostfixMathCommand(2));
    }
    
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
    }
  }
/*@egen*/
  ]
}

void UnaryExpressionNotPlusMinus() :
{
	String identString = "";
	int type;
}
{
	AnyConstant()
|
	( LOOKAHEAD({ getToken(1).kind == IDENTIFIER &&
				  jep.funTab.containsKey(getToken(1).image) })
		Function()
		|
		Variable()
            |Piecewise()
	)
	|
	"(" Expression() ")"
}


void Variable() :
{
	String identString = "";
}
{/*@bgen(jjtree) VarNode */
        {
          ASTVarNode jjtn001 = new ASTVarNode(JJTVARNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(identString = Identifier()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
	{
		if (jep.symTab.containsKey(identString)) {
			jjtn001.setName(identString);
		} else {
			jep.symTab.put(identString,identString);
			jjtn001.setName(identString);
		}
	}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/

}



void Function() :
{
	int reqArguments = 0;
	String identString = "";
}
{/*@bgen(jjtree) FunNode */
        {
          ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	( identString = Identifier()
		{
			if (jep.funTab.containsKey(identString)) {
				//Set number of required arguments
				reqArguments =
					((PostfixMathCommandI)jep.funTab.get(identString)).getNumberOfParameters();
				jjtn001.setFunction(identString,
					(PostfixMathCommandI)jep.funTab.get(identString));
			} else {
				addToErrorList("!!! Unrecognized function \"" + identString +"\"");
			}
		}
		
		("("ArgumentList(reqArguments, identString)")")
		
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/
}

void NotConnectiveCondition():
{
}
{/*@bgen(jjtree) #FunNode( 1) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<NOT> ConnectiveCondition()/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn001,  1);
       jjtc001 = false;
     }
/*@egen*/
     {
	    jjtn001.setFunction("not",  new PostfixMathCommand(1));
     }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
      }
    }
/*@egen*/
    
}

void Condition():
{
}
{
  
  Expression() 
  (/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc001 = true;
       jjtree.openNodeScope(jjtn001);
     }
     try {
/*@egen*/ 
     ( <GT> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn001,  2);
         jjtc001 = false;
       }
/*@egen*/
       {
	    jjtn001.setFunction("gt",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte001) {
       if (jjtc001) {
         jjtree.clearNodeScope(jjtn001);
         jjtc001 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte001 instanceof RuntimeException) {
         throw (RuntimeException)jjte001;
       }
       if (jjte001 instanceof ParseException) {
         throw (ParseException)jjte001;
       }
       throw (Error)jjte001;
     } finally {
       if (jjtc001) {
         jjtree.closeNodeScope(jjtn001,  2);
       }
     }
/*@egen*/
     |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
     }
     try {
/*@egen*/
     ( <LT> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn002,  2);
         jjtc002 = false;
       }
/*@egen*/
       {
	    jjtn002.setFunction("lt",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte002) {
       if (jjtc002) {
         jjtree.clearNodeScope(jjtn002);
         jjtc002 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte002 instanceof RuntimeException) {
         throw (RuntimeException)jjte002;
       }
       if (jjte002 instanceof ParseException) {
         throw (ParseException)jjte002;
       }
       throw (Error)jjte002;
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002,  2);
       }
     }
/*@egen*/
     |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc003 = true;
       jjtree.openNodeScope(jjtn003);
     }
     try {
/*@egen*/
     ( <EQ> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn003,  2);
         jjtc003 = false;
       }
/*@egen*/
       {
	    jjtn003.setFunction("eq",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte003) {
       if (jjtc003) {
         jjtree.clearNodeScope(jjtn003);
         jjtc003 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte003 instanceof RuntimeException) {
         throw (RuntimeException)jjte003;
       }
       if (jjte003 instanceof ParseException) {
         throw (ParseException)jjte003;
       }
       throw (Error)jjte003;
     } finally {
       if (jjtc003) {
         jjtree.closeNodeScope(jjtn003,  2);
       }
     }
/*@egen*/
     |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn004 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc004 = true;
       jjtree.openNodeScope(jjtn004);
     }
     try {
/*@egen*/
     ( <LE> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn004,  2);
         jjtc004 = false;
       }
/*@egen*/
       {
	    jjtn004.setFunction("leq",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte004) {
       if (jjtc004) {
         jjtree.clearNodeScope(jjtn004);
         jjtc004 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte004 instanceof RuntimeException) {
         throw (RuntimeException)jjte004;
       }
       if (jjte004 instanceof ParseException) {
         throw (ParseException)jjte004;
       }
       throw (Error)jjte004;
     } finally {
       if (jjtc004) {
         jjtree.closeNodeScope(jjtn004,  2);
       }
     }
/*@egen*/
     |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn005 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc005 = true;
       jjtree.openNodeScope(jjtn005);
     }
     try {
/*@egen*/
     ( <GE> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn005,  2);
         jjtc005 = false;
       }
/*@egen*/
       {
	    jjtn005.setFunction("geq",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte005) {
       if (jjtc005) {
         jjtree.clearNodeScope(jjtn005);
         jjtc005 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte005 instanceof RuntimeException) {
         throw (RuntimeException)jjte005;
       }
       if (jjte005 instanceof ParseException) {
         throw (ParseException)jjte005;
       }
       throw (Error)jjte005;
     } finally {
       if (jjtc005) {
         jjtree.closeNodeScope(jjtn005,  2);
       }
     }
/*@egen*/
     |/*@bgen(jjtree) #FunNode( 2) */
     {
       ASTFunNode jjtn006 = new ASTFunNode(JJTFUNNODE);
       boolean jjtc006 = true;
       jjtree.openNodeScope(jjtn006);
     }
     try {
/*@egen*/
     ( <NE> Expression()/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn006,  2);
         jjtc006 = false;
       }
/*@egen*/
       {
	    jjtn006.setFunction("neq",  new PostfixMathCommand(2));
       }
     )/*@bgen(jjtree)*/
     } catch (Throwable jjte006) {
       if (jjtc006) {
         jjtree.clearNodeScope(jjtn006);
         jjtc006 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte006 instanceof RuntimeException) {
         throw (RuntimeException)jjte006;
       }
       if (jjte006 instanceof ParseException) {
         throw (ParseException)jjte006;
       }
       throw (Error)jjte006;
     } finally {
       if (jjtc006) {
         jjtree.closeNodeScope(jjtn006,  2);
       }
     }
/*@egen*/
  )
  
}

void ConnectiveCondition():{}
{
  Condition()
  (/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn001 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    ( <AND> Condition()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtc001 = false;
      }
/*@egen*/ 
      {
	   jjtn001.setFunction("and",  new PostfixMathCommand(2));
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/
    |/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn002 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/
    ( <OR> Condition()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/ 
      {
	   jjtn002.setFunction("or",  new PostfixMathCommand(2));
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002,  2);
      }
    }
/*@egen*/
    |/*@bgen(jjtree) #FunNode( 2) */
    {
      ASTFunNode jjtn003 = new ASTFunNode(JJTFUNNODE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/
    ( <XOR> Condition()/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn003,  2);
        jjtc003 = false;
      }
/*@egen*/ 
      {
	   jjtn003.setFunction("xor",  new PostfixMathCommand(2));
      }
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        throw (RuntimeException)jjte003;
      }
      if (jjte003 instanceof ParseException) {
        throw (ParseException)jjte003;
      }
      throw (Error)jjte003;
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003,  2);
      }
    }
/*@egen*/

  )*

}

void Piecewise():{}
{/*@bgen(jjtree) Piecewise */
   {
     ASTPiecewise jjtn004 = new ASTPiecewise(JJTPIECEWISE);
     boolean jjtc004 = true;
     jjtree.openNodeScope(jjtn004);
   }
   try {
/*@egen*/
   (/*@bgen(jjtree) IfThen */
        {
          ASTIfThen jjtn001 = new ASTIfThen(JJTIFTHEN);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/ 
	(<IF> "(" (ConnectiveCondition() ) 
	     ")" <THEN> 
	     "(" (Expression()))/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/ 
           ")" (<ELSEIF> "("/*@bgen(jjtree) ElseIfThen */
                              {
                                ASTElseIfThen jjtn002 = new ASTElseIfThen(JJTELSEIFTHEN);
                                boolean jjtc002 = true;
                                jjtree.openNodeScope(jjtn002);
                              }
                              try {
/*@egen*/  (ConnectiveCondition() ")" <THEN> "(" (Expression()))/*@bgen(jjtree)*/
                              } catch (Throwable jjte002) {
                                if (jjtc002) {
                                  jjtree.clearNodeScope(jjtn002);
                                  jjtc002 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte002 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte002;
                                }
                                if (jjte002 instanceof ParseException) {
                                  throw (ParseException)jjte002;
                                }
                                throw (Error)jjte002;
                              } finally {
                                if (jjtc002) {
                                  jjtree.closeNodeScope(jjtn002, true);
                                }
                              }
/*@egen*/ ")")* 
           <ELSE> "("/*@bgen(jjtree) Else */
                      {
                        ASTElse jjtn003 = new ASTElse(JJTELSE);
                        boolean jjtc003 = true;
                        jjtree.openNodeScope(jjtn003);
                      }
                      try {
/*@egen*/ (Expression())/*@bgen(jjtree)*/
                      } catch (Throwable jjte003) {
                        if (jjtc003) {
                          jjtree.clearNodeScope(jjtn003);
                          jjtc003 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte003 instanceof RuntimeException) {
                          throw (RuntimeException)jjte003;
                        }
                        if (jjte003 instanceof ParseException) {
                          throw (ParseException)jjte003;
                        }
                        throw (Error)jjte003;
                      } finally {
                        if (jjtc003) {
                          jjtree.closeNodeScope(jjtn003, true);
                        }
                      }
/*@egen*/ ")" 
   )/*@bgen(jjtree)*/
   } catch (Throwable jjte004) {
     if (jjtc004) {
       jjtree.clearNodeScope(jjtn004);
       jjtc004 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte004 instanceof RuntimeException) {
       throw (RuntimeException)jjte004;
     }
     if (jjte004 instanceof ParseException) {
       throw (ParseException)jjte004;
     }
     throw (Error)jjte004;
   } finally {
     if (jjtc004) {
       jjtree.closeNodeScope(jjtn004, true);
     }
   }
/*@egen*/ 
}


void ArgumentList(int reqArguments, String functionName) :
{
	int count = 0;
	String errorStr = "";
}
{
	[
	Expression() { count++; }
	(
		","
		Expression() { count++; }
	)*
	]
    {
    	if (reqArguments != count && reqArguments != -1) {
			errorStr = "Function \"" + functionName +"\" requires "
			           + reqArguments + " parameter";
			if (reqArguments!=1) errorStr += "s";
			addToErrorList(errorStr);
		}
    }
}


    



String Identifier() :
{
  Token t;
}
{
        
	t=<IDENTIFIER>
	{
		return t.image;
	}
}


void AnyConstant()          :
{/*@bgen(jjtree) Constant */
        ASTConstant jjtn000 = new ASTConstant(JJTCONSTANT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Object value;
}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	value = RealConstant()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ {
		jjtn000.setValue(value);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Object RealConstant() :
{
  Token t;
  Object value;
}
{
	(t=<INTEGER_LITERAL>
	|
	t=<FLOATING_POINT_LITERAL>)
	{
		try {
			Double temp = new Double(t.image);
			value = jep.getNumberFactory().createNumber(temp.doubleValue());
		} catch (Exception e) {
			value = null;
			addToErrorList("Can't parse \"" + t.image + "\"");
		}
	
		return value;
	}
}
